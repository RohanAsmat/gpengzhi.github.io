---
title: 'Breadth-first Search'
date: 2017-08-10
permalink: /posts/2017/08/10/blog-post-2/
---

Breadth-first search (BFS) is an algorithm for traversing or searching tree or graph data structures. It starts at the tree root (or some arbitrary node of a graph, sometimes referred to as a 'search key') and explores the neighbor nodes first, before moving to the next level neighbors.

## 101. Symmetric Tree
<pre>
class Solution(object):
    
    def isSymmetric(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        if root == None:
            return True
        else:
            return self.helper(root.left, root.right)
        
    def helper(self, left, right):
        if left == None and right == None:
            return True
        elif left == None or right == None:
            return False
        else:
            return (left.val == right.val) and self.isMirror(left.left, right.right) and self.isMirror(left.right, right.left)
</pre>
Time Complexity: O(n), Space Complexity: O(1).

## 102. Binary Tree Level Order Traversal
<pre>
class Solution(object):
    
    def __init__(self):
        self.dict = {}
    
    def levelOrder(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        self.helper(root, 0)
        res = []
        for key in sorted(self.dict.keys()):
            res.append(self.dict[key])
        return res
        
        
    def helper(self, root, level):
        if root != None:
            if level in self.dict:
                self.dict[level].append(root.val)
            else:
                self.dict[level] = [root.val]
            self.helper(root.left, level+1)
            self.helper(root.right, level+1)
</pre>
Time Complexity: O(n), Space Complexity: O(n).

## 103. Binary Tree Zigzag Level Order Traversal
<pre>
class Solution(object):

    def __init__(self):
        self.dict = {}
    
    def zigzagLevelOrder(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        self.helper(root, 0)
        res = []
        d = 1
        for key in sorted(self.dict.keys()):
            res.append(self.dict[key][::d])
            d = -d
        return res
        
    def helper(self, root, level):
        if root != None:
            if level in self.dict:
                self.dict[level].append(root.val)
            else:
                self.dict[level] = [root.val]
            self.helper(root.left, level+1)
            self.helper(root.right, level+1)
</pre>
Time Complexity: O(n), Space Complexity: O(n).

## 107. Binary Tree Level Order Traversal II
<pre>
class Solution(object):
    
    def __init__(self):
        self.dict = {}
    
    def levelOrderBottom(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        self.helper(root, 0)
        res = []
        for key in sorted(self.dict.keys(), reverse=True):
            res.append(self.dict[key])
        return res
    
    def helper(self, root, level):
        if root != None:
            if level in self.dict:
                self.dict[level].append(root.val)
            else:
                self.dict[level] = [root.val]
            self.helper(root.left, level+1)
            self.helper(root.right, level+1)
</pre>
Time Complexity: O(n), Space Complexity: O(n).

## 111. Minimum Depth of Binary Tree
<pre>
class Solution(object):

    def minDepth(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        if root == None:
            return 0
        if root.left != None and root.right == None:
            return self.minDepth(root.left)+1
        elif root.left == None and root.right != None:
            return self.minDepth(root.right)+1
        else:
            return min(self.minDepth(root.left), self.minDepth(root.right))+1
</pre>
Time Complexity: O(n), Space Complexity: O(1).

## 130. Surrounded Regions
<pre>
class Solution(object):
    
    def solve(self, board):
        """
        :type board: List[List[str]]
        :rtype: void Do not return anything, modify board in-place instead.
        """
        if len(board) == 0 or len(board[0]) == 0:
            return
        m = len(board)
        n = len(board[0])
        visited = [[False for _ in range(n)] for _ in range(m)]
        for i in range(m):
            if board[i][0] == 'O' and visited[i][0] == False:
                self.helper(board, visited, i, 0, m, n)
            if board[i][n-1] == 'O' and visited[i][n-1] == False:
                self.helper(board, visited, i, n-1, m, n)
        for j in range(n):
            if board[0][j] == 'O' and visited[0][j] == False:
                self.helper(board, visited, 0, j, m, n)
            if board[m-1][j] == 'O' and visited[m-1][j] == False:
                self.helper(board, visited, m-1, j, m, n)
        for i in range(m):
            for j in range(n):
                if board[i][j] == 'O' and visited[i][j] == False:
                    board[i][j] = 'X'
        
    def helper(self, board, visited, i, j, m, n):
        if 0 <= i < m and 0 <= j < n and board[i][j] == 'O' and visited[i][j] == False:
            visited[i][j] = True
            self.helper(board, visited, i-1, j, m, n)
            self.helper(board, visited, i+1, j, m, n)
            self.helper(board, visited, i, j+1, m, n)
            self.helper(board, visited, i, j-1, m, n)
</pre>
Time Complexity: O(mn), Space Complexity: O(mn).

## 133. Clone Graph
<pre>
</pre>

## 199. Binary Tree Right Side View
<pre>
</pre>

## 200. Number of Islands
<pre>
</pre>

## 207. Course Schedule
<pre>
</pre>

## 210. Course Schedule II
<pre>
</pre>

## 279. Perfect Squares
<pre>
</pre>

## 310. Minimum Height Trees
<pre>
</pre>

## 417. Pacific Atlantic Water Flow
<pre>
</pre>

## 513. Find Bottom Left Tree Value
<pre>
</pre>

## 515. Find Largest Value in Each Tree Row
<pre>
</pre>

## 529. Minesweeper
<pre>
</pre>

## 542. 01 Matrix
<pre>
</pre>
