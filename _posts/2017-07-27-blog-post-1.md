---
title: 'Tree'
date: 2017-07-27
permalink: /posts/2017/07/27/blog-post-1/
---

In computer science, a tree is a widely used abstract data type (ADT)—or data structure implementing this ADT—that simulates a hierarchical tree structure, with a root value and subtrees of children with a parent node, represented as a set of linked nodes.

Definition for a binary tree node.
<pre>
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
</pre>

## 94. Binary Tree Inorder Traversal
<pre>
class Solution(object):
    
    def inorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        res = []
        self.helper(root, res)
        return res
        
    def helper(self, root, res):
        if root != None:
            self.helper(root.left, res)
            res.append(root.val)
            self.helper(root.right, res)
</pre>
Time Complexity: O(n), Space Complexity: O(n).
<pre>
class Solution(object):
    
    def inorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        res = []
        stack = []
        while True:
            while root != None:
                stack.append(root)
                root = root.left
            if stack == []:
                return res
            node = stack.pop()
            res.append(node.val)
            root = node.right
</pre>
Time Complexity: O(n), Space Complexity: O(n).

## 95. Unique Binary Search Trees II
<pre>
class Solution(object):
    
    def generateTrees(self, n):
        """
        :type n: int
        :rtype: List[TreeNode]
        """
        if n == 0:
            return []
        return self.helper(range(1,n+1))
    
    def helper(self, candidates):
        if len(candidates) == 0:
            return [None]
        res = []
        for i in range(len(candidates)):
            left = self.helper(candidates[:i])
            right = self.helper(candidates[i+1:])
            for l in left:
                for r in right:
                    root = TreeNode(candidates[i])
                    root.left = l
                    root.right = r
                    res.append(root)
        return res
</pre>
Time Complexity: O(# of combinations), Space Complexity: O(# of combinations*n).

## 96. Unique Binary Search Trees
<pre>
class Solution(object):
    
    def __init__(self):
        self.dict = {0:1, 1:1}
    
    def numTrees(self, n):
        """
        :type n: int
        :rtype: int
        """
        return self.helper(n)
        
    def helper(self, n):
        if n in self.dict:
            return self.dict[n]
        else:
            res = 0
            for i in range(n):
                res += self.helper(i)*self.helper(n-1-i)
            self.dict[n] = res
            return self.dict[n]
</pre>
Time Complexity: O(n), Space Complexity: O(n).

## 98. Validate Binary Search Tree
<pre>
class Solution(object):
    
    def isValidBST(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        res = []
        self.helper(root, res)
        return res == sorted(res) and len(res) == len(set(res))
        
    def helper(self, root, res):
        if root != None:
            self.helper(root.left, res)
            res.append(root.val)
            self.helper(root.right, res)
</pre>
Time Complexity: O(nlog(n)), Space Complexity: O(n).

## 100. Same Tree
<pre>
class Solution(object):
    
    def isSameTree(self, p, q):
        """
        :type p: TreeNode
        :type q: TreeNode
        :rtype: bool
        """
        if p == None and q == None:
            return True
        elif p == None or q == None:
            return False
        else:
            return (p.val == q.val) and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)
</pre>
Time Complexity: O(n), Space Complexity: O(1).

## 101. Symmetric Tree
<pre>
class Solution(object):
    
    def isSymmetric(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        if root == None:
            return True
        else:
            return self.helper(root.left, root.right)
        
    def helper(self, left, right):
        if left == None and right == None:
            return True
        elif left == None or right == None:
            return False
        else:
            return (left.val == right.val) and self.isMirror(left.left, right.right) and self.isMirror(left.right, right.left)
</pre>
Time Complexity: O(n), Space Complexity: O(1).

## 102. Binary Tree Level Order Traversal
<pre>
class Solution(object):
    
    def __init__(self):
        self.dict = {}
    
    def levelOrder(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        self.helper(root, 0)
        res = []
        for key in sorted(self.dict.keys()):
            res.append(self.dict[key])
        return res
        
    def helper(self, root, level):
        if root != None:
            if level in self.dict:
                self.dict[level].append(root.val)
            else:
                self.dict[level] = [root.val]
            self.helper(root.left, level+1)
            self.helper(root.right, level+1)
</pre>
Time Complexity: O(n), Space Complexity: O(n).

## 103. Binary Tree Zigzag Level Order Traversal
<pre>
class Solution(object):
    
    def __init__(self):
        self.dict = {}
    
    def zigzagLevelOrder(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        self.helper(root, 0)
        res = []
        d = 1
        for key in sorted(self.dict.keys()):
            res.append(self.dict[key][::d])
            d = -d
        return res
        
    def helper(self, root, level):
        if root != None:
            if level in self.dict:
                self.dict[level].append(root.val)
            else:
                self.dict[level] = [root.val]
            self.helper(root.left, level+1)
            self.helper(root.right, level+1)
</pre>
Time Complexity: O(n), Space Complexity: O(n).

## 104. Maximum Depth of Binary Tree
<pre>
class Solution(object):
    
    def maxDepth(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        if root == None:
            return 0
        else:
            return max(self.maxDepth(root.left), self.maxDepth(root.right))+1
</pre>
Time Complexity: O(n), Space Complexity: O(1).

## 105. Construct Binary Tree from Preorder and Inorder Traversal
<pre>
class Solution(object):
    
    def buildTree(self, preorder, inorder):
        """
        :type preorder: List[int]
        :type inorder: List[int]
        :rtype: TreeNode
        """
        if len(preorder) != 0:
            root = TreeNode(preorder[0])
            ind = inorder.index(preorder[0])
            root.left = self.buildTree(preorder[1:ind+1], inorder[:ind])
            root.right = self.buildTree(preorder[ind+1:], inorder[ind+1:])
            return root
</pre>
Time Complexity: O(n), Space Complexity: O(n).

## 106. Construct Binary Tree from Inorder and Postorder Traversal
<pre>
class Solution(object):
    
    def buildTree(self, inorder, postorder):
        """
        :type inorder: List[int]
        :type postorder: List[int]
        :rtype: TreeNode
        """
        if len(inorder) != 0:
            root = TreeNode(postorder[-1])
            ind = inorder.index(postorder[-1])
            root.left = self.buildTree(inorder[:ind], postorder[:ind])
            root.right = self.buildTree(inorder[ind+1:], postorder[ind:len(postorder)-1])
            return root
</pre>
Time Complexity: O(n), Space Complexity: O(n).

## 107. Binary Tree Level Order Traversal II
<pre>
class Solution(object):
    
    def __init__(self):
        self.dict = {}
    
    def levelOrderBottom(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        self.helper(root, 0)
        res = []
        for key in sorted(self.dict.keys(), reverse=True):
            res.append(self.dict[key])
        return res
    
    def helper(self, root, level):
        if root != None:
            if level in self.dict:
                self.dict[level].append(root.val)
            else:
                self.dict[level] = [root.val]
            self.helper(root.left, level+1)
            self.helper(root.right, level+1)
</pre>
Time Complexity: O(n), Space Complexity: O(n).

## 108. Convert Sorted Array to Binary Search Tree
<pre>
class Solution(object):
    
    def sortedArrayToBST(self, nums):
        """
        :type nums: List[int]
        :rtype: TreeNode
        """
        if len(nums) != 0:
            root = TreeNode(nums[len(nums)/2])
            root.left = self.sortedArrayToBST(nums[0:len(nums)/2])
            root.right = self.sortedArrayToBST(nums[len(nums)/2+1:len(nums)])
            return root
        else:
            return None
</pre>
Time Complexity: O(n), Space Complexity: O(1).

## 110. Balanced Binary Tree
<pre>
class Solution(object):
    
    def isBalanced(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        if root != None:
            if -1 <= self.depth(root.left) - self.depth(root.right) <= 1:
                return self.isBalanced(root.left) and self.isBalanced(root.right)
            else:
                return False
        else:
            return True
        
    def depth(self, root):
        if root != None:
            return max(self.depth(root.left), self.depth(root.right))+1
        else:
            return 0
</pre>
Time Complexity: O(n^2), Space Complexity: O(1).

## 111. Minimum Depth of Binary Tree
<pre>
class Solution(object):
    
    def minDepth(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        if root == None:
            return 0
        if root.left != None and root.right == None:
            return self.minDepth(root.left)+1
        elif root.left == None and root.right != None:
            return self.minDepth(root.right)+1
        else:
            return min(self.minDepth(root.left), self.minDepth(root.right))+1
</pre>
Time Complexity: O(n), Space Complexity: O(1).

## 112. Path Sum
<pre>
class Solution(object):
    
    def hasPathSum(self, root, sum):
        """
        :type root: TreeNode
        :type sum: int
        :rtype: bool
        """
        if root != None:
            if root.val == sum and root.left == None and root.right == None:
                return True
            else:
                return self.hasPathSum(root.left, sum-root.val) or self.hasPathSum(root.right, sum-root.val)
        else:
            return False
</pre>
Time Complexity: O(n), Space Complexity: O(1).

## 113. Path Sum II
<pre>
</pre>

## 114. Flatten Binary Tree to Linked List
<pre>
</pre>

## 116. Populating Next Right Pointers in Each Node
<pre>
</pre>

## 117. Populating Next Right Pointers in Each Node II
<pre>
</pre>

## 129. Sum Root to Leaf Numbers
<pre>
</pre>

## 144. Binary Tree Preorder Traversal
<pre>
</pre>

## 173. Binary Search Tree Iterator
<pre>
</pre>

## 199. Binary Tree Right Side View
<pre>
</pre>

## 222. Count Complete Tree Nodes
<pre>
</pre>

## 226. Invert Binary Tree
<pre>
</pre>

## 230. Kth Smallest Element in a BST
<pre>
</pre>

## 235. Lowest Common Ancestor of a Binary Search Tree
<pre>
</pre>

## 236. Lowest Common Ancestor of a Binary Tree
<pre>
</pre>

## 257. Binary Tree Paths
<pre>
</pre>

## 337. House Robber III
<pre>
</pre>

## 404. Sum of Left Leaves
<pre>
</pre>

## 437. Path Sum III
<pre>
</pre>

## 449. Serialize and Deserialize BST
<pre>
</pre>

## 450. Delete Node in a BST
<pre>
</pre>

## 501. Find Mode in Binary Search Tree
<pre>
</pre>

## 508. Most Frequent Subtree Sum
<pre>
</pre>

## 513. Find Bottom Left Tree Value
<pre>
</pre>

## 515. Find Largest Value in Each Tree Row
<pre>
</pre>

## 538. Convert BST to Greater Tree
<pre>
</pre>

## 543. Diameter of Binary Tree
<pre>
</pre>

## 563. Binary Tree Tilt
<pre>
</pre>

## 572. Subtree of Another Tree
<pre>
</pre>

## 606. Construct String from Binary Tree
<pre>
</pre>

## 617. Merge Two Binary Trees
<pre>
</pre>

## 623. Add One Row to Tree
<pre>
</pre>

## 637. Average of Levels in Binary Tree
<pre>
</pre>
