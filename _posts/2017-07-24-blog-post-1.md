---
title: 'Array'
date: 2017-07-24
permalink: /posts/2017/07/24/blog-post-1/
---

It is hard to summarize a general method for this category. Instead I will provide the ideas for some of the problems.

## 1. Two Sum
<pre>
class Solution(object):
    
    def twoSum(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        if len(nums) <= 1:
            return False
        dict = {}
        for i in range(len(nums)):
            if nums[i] in dict:
                return [dict[nums[i]],i]
            else:
                dict[target-nums[i]] = i
</pre>
Time Complexity: O(n), Space Complexity: O(n).

## 11. Container With Most Water
Idea: Set two pointers initialized at both ends of the array. Every time move the smaller value pointer to inner array. Then after the two pointers meet, all possible max cases have been scanned and the max situation is 100% reached somewhere in the scan.
<pre>
class Solution(object):
    
    def maxArea(self, height):
        """
        :type height: List[int]
        :rtype: int
        """
        l = 0
        r = len(height)-1
        res = 0
        while l < r:
            res = max(res, min(height[l], height[r])*(r-l))
            if height[l] <= height[r]:
                l += 1
            else:
                r -= 1
        return res
</pre>
Time Complexity: O(n), Space Complexity: O(1).

## 15. 3Sum
<pre>
class Solution(object):
    
    def threeSum(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        res = set()
        nums = sorted(nums)
        for i in range(len(nums)):
            if i > 0 and nums[i] == nums[i-1]:
                continue
            dict = {}
            target = -nums[i]
            for j in range(i+1, len(nums)):
                if nums[j] in dict:
                    res.add(tuple([nums[i], nums[dict[nums[j]]], nums[j]]))
                else:
                    dict[target-nums[j]] = j
        return list(res)
</pre>
Time Complexity: O(n^2), Space Complexity: max(O(size of "res"), O(size of "dict")).

## 16. 3Sum Closest
<pre>
class Solution(object):
    
    def threeSumClosest(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        nums = sorted(nums)
        res = nums[0]+nums[1]+nums[2]
        for i in range(len(nums)):
            l = i+1
            r = len(nums)-1
            while l < r:
                sum = nums[i]+nums[l]+nums[r]
                if sum == target:
                    return sum
                if abs(sum-target) < abs(res-target):
                    res = sum
                if sum > target:
                    r -= 1
                if sum < target:
                    l += 1
        return res
</pre>
Time Complexity: O(n^2), Space Complexity: O(1).

## 18. 4Sum
<pre>
class Solution(object):
    
    def fourSum(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[List[int]]
        """
        nums = sorted(nums)
        n = len(nums)
        res = set()
        for i in range(n):
            if i > 0 and nums[i] == nums[i-1]:
                continue
            for j in range(i+1, n):
                if j > i+1 and nums[j] == nums[j-1]:
                    continue
                dict = {}
                aim = target-nums[i]-nums[j]
                for k in range(j+1, n):
                    if nums[k] in dict:
                        res.add(tuple([nums[i], nums[j], nums[dict[nums[k]]], nums[k]]))
                    else:
                        dict[aim-nums[k]] = k
        return list(res)
</pre>
Time Complexity: O(n^3), Space Complexity: max(O(size of "res"), O(size of "dict")).

## 26. Remove Duplicates from Sorted Array
<pre>
class Solution(object):
    
    def removeDuplicates(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        length = 0
        i = 0
        while i < len(nums):
            if i == 0 or nums[i-1] != nums[i]:
                nums[length] = nums[i]
                length = length+1
            i = i+1
        return length
</pre>
Time Complexity: O(n), Space Complexity: O(1).

## 27. Remove Element
<pre>
class Solution(object):
    
    def removeElement(self, nums, val):
        """
        :type nums: List[int]
        :type val: int
        :rtype: int
        """
        length = 0
        for i in range(len(nums)):
            if nums[i] != val:
                nums[length] = nums[i]
                length += 1
        return length
</pre>
Time Complexity: O(n), Space Complexity: O(1).

## 31. Next Permutation
<pre>
class Solution(object):
    
    def nextPermutation(self, nums):
        """
        :type nums: List[int]
        :rtype: void Do not return anything, modify nums in-place instead.
        """
        r = len(nums)-1
        while nums[r] <= nums[r-1] and r > 0:
            r -= 1
        if r == 0:
            nums.reverse()
        else:    
            i = len(nums)-1
            while nums[i] <= nums[r-1]:
                i -= 1             
            nums[r-1], nums[i] = nums[i], nums[r-1]
            nums[r:] = nums[r:][::-1]   
</pre>
Time Complexity: O(n), Space Complexity: O(n).

## 33. Search in Rotated Sorted Array
<pre>
class Solution(object):
    
    def search(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        l = 0
        r = len(nums)-1
        while l <= r:
            mid = (l+r)/2
            if nums[mid] == target:
                return mid
            if nums[mid] >= nums[l]:
                if nums[l] <= target < nums[mid]:
                    r = mid-1
                else:
                    l = mid+1
            else:
                if nums[mid] < target <= nums[r]:
                    l = mid+1
                else:
                    r = mid-1
        return -1
</pre>
Time Complexity: O(log(n)), Space Complexity: O(1).

## 34. Search for a Range
<pre>
</pre>

## 35. Search Insert Position
<pre>
class Solution(object):
    
    def searchInsert(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        l = 0
        r = len(nums)-1
        if target > nums[r]:
            return r+1
        while l < r:
            mid = (l+r)/2
            if nums[mid] == target:
                return mid
            if nums[mid] < target:
                l = mid+1
            if nums[mid] > target:
                r = mid
        return r
</pre>
Time Complexity: O(log(n)), Space Complexity: O(1).

## 39. Combination Sum
<pre>
class Solution(object):
    
    def combinationSum(self, candidates, target):
        """
        :type candidates: List[int]
        :type target: int
        :rtype: List[List[int]]
        """
        res = []
        self.helper(0, candidates, target, [], res)
        return res
        
    def helper(self, index, candidates, target, path, res):
        if sum(path) > target:
            return
        elif sum(path) == target:
            res.append(path)
            return
        else:
            for i in range(index, len(candidates)):
                self.helper(i, candidates, target, path+[candidates[i]], res)
</pre>
Time Complexity: O(# of combinations), Space Complexity: O(n*(# of combinations)).

## 40. Combination Sum II
<pre>
class Solution(object):
    
    def combinationSum2(self, candidates, target):
        """
        :type candidates: List[int]
        :type target: int
        :rtype: List[List[int]]
        """
        res = []
        self.helper(0, sorted(candidates), target, [], res)
        return res
        
    def helper(self, index, candidates, target, path, res):
        if sum(path) > target:
            return
        elif sum(path) == target:
            res.append(path)
            return
        else:
            for i in range(index, len(candidates)):
                if i > index and candidates[i] == candidates[i-1]:
                    continue
                else:
                    self.helper(i+1, candidates, target, path+[candidates[i]], res)
</pre>
Time Complexity: O(# of combinations), Space Complexity: O(n*(# of combinations)).

## 48. Rotate Image
Pay attention to the copy of the matrix.
<pre>
class Solution(object):
    
    def rotate(self, matrix):
        """
        :type matrix: List[List[int]]
        :rtype: void Do not return anything, modify matrix in-place instead.
        """
        n = len(matrix)
        res = [x[:] for x in matrix]
        for i in range(n):
            for j in range(n):
                matrix[j][n-i-1] = res[i][j]
</pre>
Time Complexity: O(n^2), Space Complexity: O(n^2).
<pre>
class Solution(object):
    
    def rotate(self, matrix):
        """
        :type matrix: List[List[int]]
        :rtype: void Do not return anything, modify matrix in-place instead.
        """
        matrix.reverse()
        for i in range(len(matrix)):
            for j in range(i+1, len(matrix)):
                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
</pre>
Time Complexity: O(n^2), Space Complexity: O(1).

## 53. Maximum Subarray
<pre>
class Solution(object):
    
    def maxSubArray(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        res = None
        presum = 0
        premin = 0
        for i in range(len(nums)):
            cursum = presum + nums[i]
            res = max(res, cursum - premin)
            premin = min(cursum, premin)
            presum = cursum
        return res
</pre>
Time Complexity: O(n), Space Complexity: O(1).

## 54. Spiral Matrix
<pre>
class Solution(object):
    
    def spiralOrder(self, matrix):
        """
        :type matrix: List[List[int]]
        :rtype: List[int]
        """
        res = []
        m = len(matrix)
        if m == 0:
            return res
        n = len(matrix[0])
        visited = [[False for _ in range(n)] for _ in range(m)]
        i = 0
        j = 0
        di = 0
        dj = 1
        while len(res) < m*n:
            res.append(matrix[i][j])
            visited[i][j] = True
            if i+di < 0 or i+di >= m or j+dj < 0 or j+dj >= n or visited[i+di][j+dj] == True:
                di, dj = dj, -di
            i += di
            j += dj
        return res
</pre>
Time Complexity: O(mn), Space Complexity: O(mn).

## 55. Jump Game
<pre>
class Solution(object):
    
    def canJump(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """
        res = 0
        for i in range(len(nums)):
            if i > res or res >= len(nums)-1:
                break
            else:
                res = max(res, i+nums[i])
        return res >= len(nums)-1
</pre>
Time Complexity: O(n), Space Complexity: O(1).

## 56. Merge Intervals
<pre>
class Solution(object):
    
    def merge(self, intervals):
        """
        :type intervals: List[Interval]
        :rtype: List[Interval]
        """
        buff = []
        for interval in intervals:
            buff.append([interval.start, interval.end])
        buff = sorted(buff)
        res = []
        for i in range(len(buff)):
            if res != [] and res[-1].end >= buff[i][0]:
                res[-1].end = max(res[-1].end, buff[i][1])
            else:
                res.append(Interval(buff[i][0], buff[i][1]))
        return res
</pre>
Time Complexity: O(nlog(n)), Space Complexity: O(n).

## 59. Spiral Matrix II
<pre>
class Solution(object):
    
    def generateMatrix(self, n):
        """
        :type n: int
        :rtype: List[List[int]]
        """
        res = [[0 for _ in range(n)] for _ in range(n)]
        i = 0
        j = 0
        di = 0
        dj = 1
        for k in range(1, n*n+1):           
            res[i][j] = k
            if i+di < 0 or i+di >= n or j+dj < 0 or j+dj >= n or res[i+di][j+dj] != 0:
                di, dj = dj, -di
            i += di
            j += dj
        return res
</pre>
Time Complexity: O(n^2), Space Complexity: O(n^2).

## 62. Unique Paths
<pre>
class Solution(object):
    
    def uniquePaths(self, m, n):
        """
        :type m: int
        :type n: int
        :rtype: int
        """
        M = [[1]+[0]*(n-1)]*m
        M[0] = [1]*n
        for i in range(1,m):
            for j in range(1,n):
                M[i][j] = M[i-1][j] + M[i][j-1]
        return M[m-1][n-1]
</pre>
Time Complexity: O(mn), Space Complexity: O(mn).

## 63. Unique Paths II
Store (i,j) or tuple([i,j]) in dictionary.
<pre>
class Solution(object):
    
    def __init__(self):
        self.dict = {}
    
    def uniquePathsWithObstacles(self, obstacleGrid):
        """
        :type obstacleGrid: List[List[int]]
        :rtype: int
        """
        return self.helper(0, 0, obstacleGrid)      
        
    def helper(self, i, j, obstacleGrid):     
        if i >= len(obstacleGrid) or j >= len(obstacleGrid[0]) or obstacleGrid[i][j] == 1:
            return 0 
        if i == len(obstacleGrid)-1 and j == len(obstacleGrid[0])-1:
            return 1 
        if (i,j) in self.dict:
            return self.dict[(i,j)]
        else:
            self.dict[(i,j)] = self.helper(i+1, j, obstacleGrid) + self.helper(i, j+1, obstacleGrid)
        return self.dict[(i,j)]
</pre>
Time complexity: O(mn), Space Complexity: O(mn).

## 64. Minimum Path Sum
<pre>
class Solution(object):
    
    def minPathSum(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        m = len(grid)
        n = len(grid[0])
        for i in range(m):
            for j in range(n):
                if i == 0 and j > 0:
                    grid[i][j] = grid[i][j-1] + grid[i][j]
                if j == 0 and i > 0:
                    grid[i][j] = grid[i-1][j] + grid[i][j]
                if i > 0 and j > 0:
                    grid[i][j] = min(grid[i-1][j], grid[i][j-1]) + grid[i][j]
        return grid[m-1][n-1]
</pre>
Time Complexity: O(mn), Space Complexity: O(1).

## 66. Plus One
<pre>
class Solution(object):
    
    def plusOne(self, digits):
        """
        :type digits: List[int]
        :rtype: List[int]
        """
        num = ''
        for digit in digits:
            num += str(digit)
        num = str(int(num)+1)
        res = []
        for i in range(len(num)):
            res.append(int(num[i]))
        return res
</pre>
Time Complexity: O(n), Space Complexity: O(n).

## 73. Set Matrix Zeroes
Use the first row and the first column as the helper.
<pre>
class Solution(object):
    
    def setZeroes(self, matrix):
        """
        :type matrix: List[List[int]]
        :rtype: void Do not return anything, modify matrix in-place instead.
        """
        m = len(matrix)
        if m == 0:
            return
        n = len(matrix[0])
        col0 = False
        for i in range(m):
            if matrix[i][0] == 0:
                col0 = True
                break
        row0 = False
        for j in range(n):
            if matrix[0][j] == 0:
                row0 = True
                break
        for i in range(1,m):
            for j in range(1,n):
                if matrix[i][j] == 0:
                    matrix[0][j] = 0
                    matrix[i][0] = 0
        for i in range(1,m):
            if matrix[i][0] == 0:
                for j in range(1,n):
                    matrix[i][j] = 0
        for j in range(1,n):
            if matrix[0][j] == 0:
                for i in range(1,m):
                    matrix[i][j] = 0
        if col0:
            for i in range(m):
                matrix[i][0] = 0
        if row0:
            for j in range(n):
                matrix[0][j] = 0
</pre>
Time Complexity: O(mn), Space Complexity: O(1).

## 74. Search a 2D Matrix
<pre>
class Solution(object):
    
    def searchMatrix(self, matrix, target):
        """
        :type matrix: List[List[int]]
        :type target: int
        :rtype: bool
        """
        m = len(matrix)
        if m == 0:
            return False
        n = len(matrix[0])
        if n == 0:
            return False
        l = 0
        r = m*n-1
        while l < r:
            mid = (l+r)/2
            if matrix[mid/n][mid%n] == target:
                return True
            elif matrix[mid/n][mid%n] > target:
                r = mid - 1
            else:
                l = mid + 1
        return matrix[l/n][r%n] == target
</pre>
Time Complexity: O(mnlog(mn)), Space Complexity: O(1).

## 75. Sort Colors
Please be careful about the change of the list when you are using loop!
<pre>
class Solution(object):
    
    def sortColors(self, nums):
        """
        :type nums: List[int]
        :rtype: void Do not return anything, modify nums in-place instead.
        """
        pos0 = 0
        pos1 = 0
        for i in range(len(nums)):
            if nums[i] == 0:
                nums.pop(i)
                nums.insert(pos0,0)
                pos0 += 1
                pos1 += 1
            elif nums[i] == 1:
                nums.pop(i)
                nums.insert(pos1, 1)
                pos1 += 1
            else:
                nums.pop(i)
                nums.insert(pos1, 2)
</pre>
Time Complexity: O(n^2), Space Complexity: O(1).

## 78. Subsets
<pre>
class Solution(object):
    
    def subsets(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        res = []
        self.helper(nums, [], res, len(nums))
        return res
        
    def helper(self, nums, path, res, n):
        if len(path) <= n:
            res.append(path)
        for i in range(len(nums)):
            self.helper(nums[i+1:], path+[nums[i]], res, n)
</pre>
Time Complexity: O(# of combinations), Space Complexity: O(n*(# of combinations)).

## 79. Word Search
<pre>
class Solution(object):
    
    def exist(self, board, word):
        """
        :type board: List[List[str]]
        :type word: str
        :rtype: bool
        """
        for i in range(len(board)):
            for j in range(len(board[0])):
                if self.helper(board, i, j, word):
                    return True
        return False
        
    def helper(self, board, i, j, word):
        if len(word) == 0:
            return True
        if i < 0 or i > len(board)-1 or j < 0 or j > len(board[0])-1:
            return False
        if board[i][j] == word[0]:
            board[i][j] = '#'
            res = self.helper(board,i-1,j,word[1:]) or self.helper(board,i+1,j,word[1:]) or self.helper(board,i,j-1,word[1:]) or self.helper(board,i,j+1,word[1:])
            board[i][j] = word[0]
            return res
        else:
            return False
</pre>
Time Complexity: O(mnk), Space Complexity: O(1).

## 80. Remove Duplicates from Sorted Array II
<pre>
class Solution(object):
    
    def removeDuplicates(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        pos = 0
        for num in nums:
            if pos < 2 or num > nums[pos-2]:
                nums[pos] = num
                pos += 1
        return pos
</pre>
Time Complexity: O(n), Space Complexity: O(1).

## 81. Search in Rotated Sorted Array II
<pre>
class Solution(object):
    
    def search(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: bool
        """
        l = 0
        r = len(nums)-1
        while l <= r:
            mid = (l+r)/2
            if nums[mid] == target:
                return True
            if nums[mid] > nums[l]:
                if nums[l] <= target < nums[mid]:
                    r = mid-1
                else:
                    l = mid+1
            elif nums[mid] < nums[l]:
                if nums[mid] < target <= nums[r]:
                    l = mid+1
                else:
                    r = mid-1
            else:
                l += 1
        return False
</pre>
Time Complexity: O(log(n)), Space Complexity: O(1).

## 88. Merge Sorted Array
Idea: fill in the entries from the largest to the smallest.
<pre>
class Solution(object):
    
    def merge(self, nums1, m, nums2, n):
        """
        :type nums1: List[int]
        :type m: int
        :type nums2: List[int]
        :type n: int
        :rtype: void Do not return anything, modify nums1 in-place instead.
        """
        while m > 0 and n > 0:
            if nums1[m-1] > nums2[n-1]:
                nums1[n+m-1] = nums1[m-1]
                m -= 1
            else:
                nums1[n+m-1] = nums2[n-1]
                n -= 1
        if n > 0:
            nums1[:n] = nums2[:n]
</pre>
Time Complexity: O(m+n), Space Complexity: O(1).

## 90. Subsets II
<pre>
class Solution(object):
    
    def subsetsWithDup(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        res = []
        self.helper(sorted(nums), [], res, len(nums))
        return res
        
    def helper(self, nums, path, res, n):
        if len(path) <= n:
            res.append(path)
        for i in range(len(nums)):
            if i > 0 and nums[i] == nums[i-1]:
                continue
            else:
                self.helper(nums[i+1:], path+[nums[i]], res, n)
</pre>
Time Complexity: max(O(# of combinations), O(nlog(n))), Space Complexity: O(n*(# of combinations)).

## 105. Construct Binary Tree from Preorder and Inorder Traversal
<pre>
class Solution(object):
    
    def buildTree(self, preorder, inorder):
        """
        :type preorder: List[int]
        :type inorder: List[int]
        :rtype: TreeNode
        """
        if len(preorder) != 0:
            root = TreeNode(preorder[0])
            ind = inorder.index(preorder[0])
            root.left = self.buildTree(preorder[1:ind+1], inorder[:ind])
            root.right = self.buildTree(preorder[ind+1:], inorder[ind+1:])
            return root
</pre>
Time Complexity: O(n), Space Complexity: O(n).

## 106. Construct Binary Tree from Inorder and Postorder Traversal
<pre>
class Solution(object):
    
    def buildTree(self, inorder, postorder):
        """
        :type inorder: List[int]
        :type postorder: List[int]
        :rtype: TreeNode
        """
        if len(inorder) != 0:
            root = TreeNode(postorder[-1])
            ind = inorder.index(postorder[-1])
            root.left = self.buildTree(inorder[:ind], postorder[:ind])
            root.right = self.buildTree(inorder[ind+1:], postorder[ind:len(postorder)-1])
            return root
</pre>
Time Complexity: O(n), Space Complexity: O(n).

## 118. Pascal's Triangle
<pre>
class Solution(object):
    
    def generate(self, numRows):
        """
        :type numRows: int
        :rtype: List[List[int]]
        """
        res = []
        for i in range(numRows):
            if i == 0:
                res.append([1])
                continue
            new_layer = []
            for j in range(i+1):
                if j == 0 or j == i:
                    new_layer.append(1)
                else:
                    new_layer.append(res[-1][j-1]+res[-1][j])
            res.append(new_layer)
        return res
</pre>
Time Complexity: O(n^2), Space Complexity: O(n^2).

## 119. Pascal's Triangle II
<pre>
class Solution(object):
    
    def getRow(self, rowIndex):
        """
        :type rowIndex: int
        :rtype: List[int]
        """
        row = [1]
        for i in range(1,rowIndex+1):
            row = [x+y for x,y in zip([0]+row, row+[0])]
        return row
</pre>
Time Complexity: O(k^2), Space Complexity: O(k).

## 120. Triangle
<pre>
class Solution(object):
    
    def minimumTotal(self, triangle):
        """
        :type triangle: List[List[int]]
        :rtype: int
        """
        m = len(triangle)
        for i in range(m-2, -1, -1):
            for j in range(len(triangle[i])):
                triangle[i][j] = min(triangle[i+1][j], triangle[i+1][j+1]) + triangle[i][j]
        return triangle[0][0]
</pre>
Time Complexity: O(n^2), Space Complexity: O(1).

## 121. Best Time to Buy and Sell Stock
<pre>
class Solution(object):
    
    def maxProfit(self, prices):
        """
        :type prices: List[int]
        :rtype: int
        """
        pre = 0
        res = 0
        for i in range(1, len(prices)):
                profit = max(pre+prices[i]-prices[i-1], 0)
                res = max(res, profit)
                pre = profit
        return res
</pre>
Time Complexity: O(n), Space Complexity: O(1).

## 122. Best Time to Buy and Sell Stock II
<pre>
class Solution(object):
    
    def maxProfit(self, prices):
        """
        :type prices: List[int]
        :rtype: int
        """
        res = 0
        for i in range(1, len(prices)):
            res += max(prices[i]-prices[i-1], 0)
        return res
</pre>
Time Complexity: O(n), Space Complexity: O(1).

## 152. Maximum Product Subarray
<pre>
</pre>

## 153. Find Minimum in Rotated Sorted Array
<pre>
</pre>

## 162. Find Peak Element
<pre>
</pre>

## 167. Two Sum II - Input array is sorted
<pre>
class Solution(object):
    
    def twoSum(self, numbers, target):
        """
        :type numbers: List[int]
        :type target: int
        :rtype: List[int]
        """
        l = 0
        r = len(numbers)-1
        while l < r:
            if numbers[l] + numbers[r] == target:
                return [l+1, r+1]
            elif numbers[l] + numbers[r] < target:
                l += 1
            else:
                r -= 1
</pre>
Time Complexity: O(n), Space Complexity: O(1).

## 169. Majority Element
<pre>
class Solution(object):
    
    def majorityElement(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        dict = {}
        n = len(nums)
        for i in range(n):
            if nums[i] in dict:
                dict[nums[i]] += 1
            else:
                dict[nums[i]] = 1
            if dict[nums[i]] > n/2:
                return nums[i]
</pre>
Time Complexity: O(n), Space Complexity: O(n).

## 189. Rotate Array
<pre>
class Solution(object):
    
    def rotate(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: void Do not return anything, modify nums in-place instead.
        """
        n = len(nums)
        k = k%n
        nums[n-k:] = nums[n-k:][::-1]
        nums[:n-k] = nums[:n-k][::-1]
        nums = nums.reverse()
</pre>
Time Complexity: O(n), Space Complexity: O(1).

## 209. Minimum Size Subarray Sum
<pre>
</pre>

## 216. Combination Sum III
<pre>
class Solution(object):
    
    def combinationSum3(self, k, n):
        """
        :type k: int
        :type n: int
        :rtype: List[List[int]]
        """
        res = []
        self.helper(range(1,10), k, n, [], res)
        return res
    
    def helper(self, candidates, k, n, path, res):        
        if k == 0 and sum(path) == n:
            res.append(path)
            return
        for i in range(len(candidates)):
            self.helper(candidates[i+1:], k-1, n, path+[candidates[i]], res)
</pre>
Time Complexity: O(# of combinations), Space Complexity: O(n*(# of combinations)).

## 217. Contains Duplicate
<pre>
class Solution(object):
    
    def containsDuplicate(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """
        res = set()
        for i in range(len(nums)):
            if nums[i] in res:
                return True
            else:
                res.add(nums[i])
        return False
</pre>
Time Complexity: O(n), Space Complexity: O(n).

## 219. Contains Duplicate II
<pre>
class Solution(object):
    
    def containsNearbyDuplicate(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: bool
        """
        dict = {}
        for i in range(len(nums)):
            if nums[i] in dict and abs(i-dict[nums[i]]) <= k:
                return True
            else:
                dict[nums[i]] = i
        return False
</pre>
Time Complexity: O(n), Space Complexity: O(n).

## 228. Summary Ranges
<pre>
</pre>

## 229. Majority Element II
<pre>
</pre>

## 238. Product of Array Except Self
<pre>
</pre>

## 268. Missing Number
<pre>
class Solution(object):
    
    def missingNumber(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        return (1+len(nums))*len(nums)/2 - sum(nums)
</pre>
Time Complexity: O(n), Space Complexity: O(1).

## 283. Move Zeroes
<pre>
class Solution(object):
    
    def moveZeroes(self, nums):
        """
        :type nums: List[int]
        :rtype: void Do not return anything, modify nums in-place instead.
        """
        j = 0
        for i in range(len(nums)):
            if nums[i] != 0:
                nums[i], nums[j] = nums[j], nums[i]
                j += 1
        return
</pre>
Time Complexity: O(n), Space Complexity: O(1).

## 287. Find the Duplicate Number
<pre>
</pre>

## 289. Game of Life
<pre>
</pre>

## 380. Insert Delete GetRandom O(1)
<pre>
</pre>

## 414. Third Maximum Number
<pre>
</pre>

## 442. Find All Duplicates in an Array
<pre>
</pre>

## 448. Find All Numbers Disappeared in an Array
Idea: For each number i in nums, we mark the number that i points as negative. Then we filter the list, get all the indexes who points to a positive number. Since those indexes are not visited.
<pre>
class Solution(object):
    
    def findDisappearedNumbers(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        for i in range(len(nums)):
            nums[abs(nums[i])-1] = -abs(nums[abs(nums[i])-1])
        res = []
        for i in range(len(nums)):
            if nums[i] > 0:
                res.append(i+1)
        return res
</pre>
Time Complexity: O(n), Space Complexity: O(1) (the returned list does not count as extra space).

## 485. Max Consecutive Ones
<pre>
</pre>

## 495. Teemo Attacking
<pre>
</pre>

## 532. K-diff Pairs in an Array
<pre>
</pre>

## 560. Subarray Sum Equals K
<pre>
</pre>

## 561. Array Partition I
<pre>
class Solution(object):
    
    def arrayPairSum(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        return sum(sorted(nums)[::2])
</pre>
Time Complexity: O(nlog(n)), Space Complexity: O(1).

## 565. Array Nesting
<pre>
</pre>

## 566. Reshape the Matrix
<pre>
</pre>

## 581. Shortest Unsorted Continuous Subarray
<pre>
</pre>

## 605. Can Place Flowers
<pre>
</pre>

## 611. Valid Triangle Number
<pre>
</pre>

## 621. Task Scheduler
<pre>
</pre>

## 628. Maximum Product of Three Numbers
<pre>
class Solution(object):
    
    def maximumProduct(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        nums = sorted(nums)
        return max(nums[-1]*nums[-2]*nums[-3], nums[-1]*nums[0]*nums[1])
</pre>
Time Complexity: O(nlog(n)), Space Complexity: O(1).

## 643. Maximum Average Subarray I
<pre>
class Solution(object):
    
    def findMaxAverage(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: float
        """
        n = len(nums)
        res = average = sum(nums[:k])*1.0/k
        for i in range(k,n):
            average += (nums[i]-nums[i-k])*1.0/k
            res = max(res, average)
        return res
</pre>
Time complexity: O(n), Space Complexity: O(1).
